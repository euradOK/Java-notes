java.lang package
=================
1.Introduction
2.Object class 
3.String class 
4.StringBuffer class
5.StringBuilder class
6.Wrapper class
7.Autoboxing & Autounboxing 
=================================


1.Introduction
---------------
We are not required to import java.lang package explicitly because all classess and 
interfaces present in lang package by default available to every java program.

2.Object class(java.lang.Object) 
--------------------------------
The most required method for every java class (whether it is predefined or customezed class)
are defined in separate class which is Object class.

Every class in java is child class of Object either directly or indirectly so that 
Object class methods by default available to every java class.

Hence Object class is considered as Root of java class.

Note:
If our class does not extend any other class then only our class is directly class 
of Object.

Example:
	class A
	{
	}
class A is child of Object.

If our class extends other class then our class is indirectly child class of Object.
Example:
	class A extends B
	{
	}
class A is a child of class B and B is child of class Object. This is multi-level inheritance and 
not multiple inheritance.
Java does not support multiple inheritance but support multi-level inheritance.

conclusion:
Either directly or indirectly Java will not support multiple inheritance with respect 
to classes.

Object class defines the following 11 methods:
1.public String toString()
2.public int hashcode()
3.public boolean equals(Object o)
4.protected native Object clone() throws CloneNotSupportedException
5.protected void finalize() throws Throwable
6.public final class getclass()
7.public final void wait() throws InterruptedException
8.public final native void wait(long ms) throws InterruptedException
9.public final void wait(long ms,int ns) throws InterruptedException
10.public native final void notify()
11.public native final void notifyAll() 

Note:
Strictly Object class class contains 12 methods the extra method is
private static native void registerNatives()
This method internally required for object class and not available for child classes
hence we are not required to consider this method.

code to list methods in object class:

import java.lang.reflect.*;	
class Test
	{
		public static void main(String [] args ) throws Exception
		{
			int count=0;
			class c=class.forName("java.lang.Object")
			Method[] m=c.getDeclaredMethods();
			for (Method m1:m )
			{
				count ++;
				System.out.println(m1.getName());
			}
			System.out.println("There is a number methods:" + count);
		}
	}


tostring ()
-----------
We can use tostring () method to get String repsentation of an object.
String s=obj.toString();

Whenever we trying to print object reference internally toString() method will be 
called.
Example:
Student s=new Student();
System.out.println(s); ====(System.out.println(s.toString())

if our class does not contain toString() method then Object class toString() method will
be excuted.
class Student 
{
	String name;
	int rollno;
	Student(String name,int rollno)
	{
		this.name=name;
		this.rollno=rollno;
	}
	public static void main(String[] args)
	{
		Student s1=new Student("eurad",101);
		Student s2=new Student("emma",102);
		
		System.out.println(s1);
		System.out.println(s1.toString());
		System.out.println(s2);
	}
}


Based on our requirement we can override toString() method to provide our own 
String representation.
Example:
class Student 
{
	String name;
	int rollno;
	Student(String name,int rollno)
	{
		this.name=name;
		this.rollno=rollno;
	}
	public String toString()
	{
		return name +"..."+ rollno;
	}
	public static void main(String[] args)
	{
		Student s1=new Student("eurad",101);
		Student s2=new Student("emma",102);
		
		System.out.println(s1);
		System.out.println(s1.toString());
		System.out.println(s2);
	}
}

2.public native int hashcode()
------------------------
For every object a unique number generated by JVM which is nothing but Hashcode.
Hashcode will not represent address of object.
JVM will use hashcode while saving object to hashing related datastructures like 
Hashtable,HashSet,HashMap ...etc

The main advantage of saving objects based on hashcode is Search Operation will 
become easy(the most powerful seach algorithm up to today is Hashing)

if we are giving to object class hashcode method it will generate hashcode 
based on address of obaject. It does not mean hashcode repsent address of object.

Based on our requirement we can override hashcode method in class to generate 
our own hashcode.

Overriding hashcode method is said to proper if and only if for every object we have
to generate a unique number as hashcode.
Example:
class Test
{	
	public static void main(String[] args)
	{
		return 100;	//improper way 
	}
}
This is improper way of overriding hashcode method because for all student object 
we are generating same number as hashcode.

Example:
class Test
{	
	public static void main(String[] args)
	{
		return rollno;	//proper way 
	}
}
This is proper way of overriding hashcode method because we are generating a different 
hashcode for every object.

toString() vs hashcode():
-------------------------
if we are giving a chance to object class to string method it will internally call
hashcode method.
public String toString()
{
	return get.class().getName +"@"+ Integer.toHexString(hashcode());
}

if we are overriding toString method then our toString method may not call hashcode 
method.
public String toString()
{
	return name +"..."+ rollno;
}

Example:
class Test
{
	Test(int i)
	{
		this.i=i;
	}
	public static void main(String[] args)
	{
		Test t1=new Test(10);
		Test t1=new Test(100);
		System.out.println(t1);		//Test@abcd
		System.out.println(t2);		//Test@abdf
	}
}

Example:
class Test
{
	Test(int i)
	{
		this.i=i;
	}
	public int hashcode()
	{
		return i;
	}
	public static void main(String[] args)
	{
		Test t1=new Test(10);
		Test t1=new Test(100);
		System.out.println(t1);		//Test@a
		System.out.println(t2);		//Test@64
	}
}

In all Wrapper classes,in all collections classes,String class,StringBuffer 
and StringBuilder classes toString method is overriden for meaningful String
repsentation hence it is recommended to override toString() method in our 
class also.


3.String class 
4.StringBuffer class
5.StringBuilder class 

6.Wrapper class:
----------------
The main objectives of wrapper classes are
	1.To wrapp primitive into object form so that we can handle primitive also just like objects.
	2.To define several utility methods which are required for primitives.

Constructors:
-------------
Almost all wrapper classes contains two constructors, one can take corresponding primitive as 
argument and the other can take String as argument.
Example01:
	Integer I=new Integer(10);
	Integer I=new Integer("10");

Example02:
	Double D=new Double(10.5);
	Double D=new Double("10.5");

If string argument not repsenting a number then we will get runtime exception saying NumberFormatException.
Example:
	Integer I=new Integer("ten"); //RE:NumberFormatException

Float class contains 3 constructors with Float,Double and String arguments.
Example:
Float f=new Float(10.5f);
Float f=new Float("10.5f")
Float f=new Float(10.5)
Float f=new Float("10.5")

Character class contains only one constructor argument which can take char argument.
Example:
	Character C=new Character('a');//valid 
	Character C=new Character("a");//Invalid 

Boolean class contains 2 constructors one can take primitive argument and other can take 
string argument.
If we boolean primitive as argument the only allowed values are true or false where case is very
important and content is important.
Example:
	Boolean B=new Boolean(true);//valid 
	Boolean B=new Boolean(false);//valid 
	Boolean B=new Boolean(True);//Invalid 
	Boolean B=new Boolean(eurad);//Invalid 

If we are passing string type as argument then case and content both are not important.
If a content is case insesitive String of "true" then it trated as as true otherwise it is treated as false.
Example:
	Boolean B=new Boolean("true"); ==>true
	Boolean B=new Boolean("True"); ==>true
	Boolean B=new Boolean("TRUE"); ==>false
	Boolean B=new Boolean("malaika");==>false 
	Boolean B=new Boolean("eurad");==>false 

Example:
	Boolean X=new Boolean("no"); 
	Boolean Y=new Boolean("yes"); 
	System.out.println(X);//false
	System.out.println(Y);//false
	System.out.println(X.equals(Y));//true

Wrapper classes		Corresponding constructor argument
Byte					byte or String	
Short					short or String
Integer					integer or String
Long					long or String 
Float					float or String or Double
Double					Double or String
Character				char 
Boolean					boolean or String 

Note:
In all wrapper classes toString() method is overriden to return content directly.
In all wrapper classes .equals() method is overriden for content comparison.

Utility Methods:
----------------
1.valueOf()
2.xxxValue()
3.parseXxx()
4.toString()

valueOf():
---------
We can use valueOf() method to create wrapper object for given primitive or String.
Every wrapper class except Character class contains static valueOf() method to create wrapper 
object for given String.

form-1:
------
public static wrapper valueOf(String s)
eg:
Integer I=Integer.valueOf("10")
Double  D=Double.valueOf("10.5")
Boolean B=Boolean.valueOf("durga")

form-2:
-------
Every Integral type wrapper class(byte,short,integer,long) contains the following valueOf()
method to create wrapper object for given specified radix string.

public static wrapper valueOf(String s,int radix);

The allowed range of radix is 2 to 36.
eg:
Integer I=Integer.valueOf("100",2);
System.out.println(I); //4

Integer I=Integer.valueOf("101",4);
System.out.println(I); //17

form-2:
-------
Every wrapper class including Character class contains a static valueOf() to create wrapper object 
for given primitive.

public static wrapper valueOf(primitive p);
eg:
Integer I=Integer.valueOf(10);
Character Ch=Character.valueOf('a');
Boolean B=Boolean.valueOf(true);


xxxValue();
-----------
We can use xxxValue() to get primitive for the given wrapper object.
Every number type wrapper class(Byte,Short,Integer,Long,Float,Double) contains the following 6 methods 
to get primitive for the given wrapper objects.

public byte byteValue();
public short shortValue();
public long longValue();
public float floatValue();
public double doubleValue();

eg:
Integer I=new Integer(10);
System.out.println(I.byteValue()); //-126
System.out.println(I.shortValue());//130
System.out.println(I.intValue());//130
System.out.println(I.longValue());//130
System.out.println(I.doubleValue());//130.0
System.out.println(I.floatValue());//130.0

Character class contains charValue() to get char primitive for given character object.

public char charValueOf();

eg:
Character Ch=new Character('a');
char c=ch.charValueOf();
System.out.println(c) //a

booleanValue()
----------------
Boolean class contains booleanValue() to get boolean primitive for the given boolen object.

public boolean booleanValue();

eg:
Boolean B=Boolean.ValueOf("eurad");
boolean b=B.booleanValue();
System.out.println(b) //false

Note:
In total 38(6*6+1+1) xxxValue() are possible.

7.Autoboxing & Autounboxing:
-----------------------------
Autoboxing:
-----------
Automatic conversion of primitive to wrapper object by compiler.
eg:
	Integer I=10; [compiler convert int to Integer automatically by autoboxing]

after compilation the above line of code will be:
	Integer I=Integer.valueOf(10);
Autoboxing concept is implemented internally by using valueOf().

Autounboxing:
-------------
Automatic conversion of wrapper object to primitive by compiler.
eg:
Integer I=new Integer(10);
int i=I; [compiler converts Integer to int automatically by automatic Autounboxing]

After compilation the above line will become 
int i=I.intValue();

That is internally Autounboxing is implemented by using xxxValue().

Eg01:
class Test
{
	static Integer I=10; //Autoboxing 

	public static void main(String[] args)
	{
		int i=I; //Autounboxing
		m1(i);  //Autounboxing
	}
	public static m1(Integer I){
		int k=I; //Autounboxing
		System.out.println(k);  //10
	}
}

Note:
Just because of Autoboxing and Autounboxing we can use primitive and wrapper object interchangeably
from 1.5 version onwards.

Eg02:
class Test
{
	static Integer I=0; //Autoboxing 

	public static void main(String[] args)
	{
		int i=I; //Autounboxing
		System.out.println(i);  // 0
	}
}

Eg.
class Test
{
	static Integer I;

	public static void main(String[] args)
	{
		int i=I; //Autounboxing  [int i=I.intValueOf()] but I==>null
		System.out.println(i);  //RE: NPE
	}
}

Note: 
On null reference if we are trying to perform Autounboxing then we will get RunTime Exception 
saying null pointer exception.

eg03:
Integer X=10;
Integer Y=X;
X++;
System.out.println(X); //11
System.out.println(Y); //10
System.out.println(X==Y); //false

Note:
All wrapper class object are immutable.i,e once we create wrapper class object we cant perform
any changes in that object.If we are trying to perform any changes, with those changes a new 
object will be created.

eg04:
Integer X=new Integer(10);
Integer Y=new Integer(10);
System.out.println(X==Y); //false

Integer X=new Integer(10);
Integer Y=10;
System.out.println(X==Y); //false 

Integer X=10;
Integer Y=10;
System.out.println(X==Y); //true

Integer X=100;
Integer Y=100;
System.out.println(X==Y); //true 

Integer X=1000;
Integer Y=1000;
System.out.println(X==Y); //false

Conclusion:
Internally to provide support for Autoboxing a buffer of wrapper object will be created at time 
of wrapper class loading.
By Autoboxing if an object is required to create first JVM will check whether this object is already
in the buffer or not. If already present in the buffer then existing buffer object will be used.

If not already available in the buffer then JVM will create a new object.
class Integer 
{
	static { -128 ...127}
} 

But buffer concept is available in the following ranges:
Byte---> always
Short---> -128 to 127
Integer---> -128 to 127
Long---> -128 to 127
Character--->-128 to 127
Boolean---> always

Except this range in all remaining cases a new object will be created.
eg:
Integer X=127;
Integer Y=127;
System.out.println(X==Y); //true 

Integer X=128;
Integer Y=128;
System.out.println(X==Y); //false

Boolean X=false;
Boolean Y=false;
System.out.println(X==Y); //true 

Double X=10.0;
Double Y=10.0;
System.out.println(X==Y); //false

Internally Autoboxing concept is implemented by using valueOf() hence buffering concept is 
applicable for valueOf() also.

eg:
Integer X=new Integer(10);
Integer Y=new Integer(10);
System.out.println(X==Y); //false

Integer X=10;
Integer Y=10;
System.out.println(X==Y); //true

Integer X=Integer.valueOf(10);
Integer Y=Integer.valueOf(10);
System.out.println(X==Y); //true

Integer X=10;
Integer Y=Integer.valueOf(10);
System.out.println(X==Y); //true


				Part-12:
				========
Relation between == and .equals() methods:
-------------------------------------------
1.If two objects are equal by == operator then this object are always equal by .equals().
	if r1==r2 is true then r1.equals() is always true 

2.If two objects are not equal by == operator then we cant conclude anything .equal().
It may returns true of false 
	if r1==r2 is false then r1.equals(r2) may return true of false and we cant expect exactly.

3.If two objects are equal by .equals() method then we cant conclude anything about == operator.
It may return true or false
	r1.equals(r2) is true then we cant conclude anything about r1==r2 
	It may return true or false.

4.If two objects are not equal by .equals() method then these object are not equal by == operator.
 r1.equals(r2) is false then r1==r2 is always false.

Differences between == operator and .equals method:
----------------------------------------------------
To use == operator compsoly should be relation between argument types(either child to parent or 
parent to child or same type) otherwise we will get compile error saying incomparable types.

If there is no relation between argument types then .equals methods wont raise any compile or 
runtime error simply it return false.

eg:
String s1=new String("eurad");
String s2=new String("eurad");
StringBuffer sb1=new StringBuffer("eurad");
StringBuffer sb2=new StringBuffer("eurad");

System.out.println(s1==s2);		//false
System.out.println(s1.equals(s2));//true
System.out.println(sb1==sb2);		//false 
System.out.println(sb1.equals(sb2));	//false
System.out.println(s1==sb1);	//CE: incomparable types:j.l.String and j.l.StringBuffer
System.out.println(s1.equals(sb1));	//false

== operator:
-----------
1.It is operator in Java applicable for both primitive and object types.
2.In case of object references == operator meant for reference(address) comparison.
3.We cant override == operator for content comparison.
4.To use == operator complsory there should be some relation between argument types(either child 
to parent or parent to child or same type) otherwise we will get compile error saying incomparable
types

.equals methods:
----------------
1.It is a method applicable only for object types but not for primitives.
2.By default .equals method present in object class also meant for reference(address) comparison.
3.We can override .equals method for content comparison.
4.If there is no realtion between argument types then .equals method wont raise any compile or 
runtime error and simply returns false.

Note: Answer in 1 Line
In general we can use == operator for reference comparison and .equals method for content comparison.

Note:
for any object reference r,r==null or r.equals(null) always returns false 

eg:
Thread t=new Thread();
System.out.println(t==null); //false
System.out.println(t.equals(null)); //false 

Note:
Hashing related datastructures follows the following fundamental rules:
	Two equivalent objects should be placed in same bucket but all object present in the same 
	bucket may not be equal

Contract between .equals and hashcode methods:
----------------------------------------------
1.If two object are equal by .equals method then their hashcode must be equal that is two 
	equivalent object should have same hashcode. i,e 
	if r1.equals(r2) is true then r1.hashCode()==r2.hashCode() is always true

Object class .equals method and hashcode method follows above contract hence whenever 
we are overriding .equals() complsory we should override hashcode method to satisfy the 
above contract.i,e 
two equivalent object should have same hashcode 

2.If two object are not equal by .equals method then there is no restrictions on their hashcode.
May be equal or may not be equal.

3.If hashcode of two objects are equal then we cant conclude anthing about .equals method it 
may returns true or false.

4.If hashcode of two objects are not equal then these objects are always not equal by .equals().

Note*:
To satisfy contract between .equals() and hashcode() whenever we overriding .equals() complsory
to override hashcode methode otherwise we wont get any compile or runtime error but it is not 
good programming practise.

In String class .equals method is overriden for content comparison and hence hashcode method is 
also overriden to generate hashcode based on content.

eg:
String s1=new String("eurad); 
String s2=new String("eurad);
System.out.println(s1.equals(s2));	//true
System.out.println(s1.hashCode());	//96873829
System.out.println(s2.hashCode());	//96873829

In StringBuffer .equals method is not overriden for content comparison and hence hashcode method
is not overriden

eg:
StringBuffer sb1=new StringBuffer("eurad"); 
StringBuffer sb2=new StringBuffer("eurad");
System.out.println(sb1.equals(sb2));	//false
System.out.println(sb1.hashCode());	//1910163204
System.out.println(sb2.hashCode());	//305623748

Qn:
Consider the following person class:
class Person
{
	public boolean equals(Object obj){
		if (obj instanceof Person)
		{
			Person p=(Person)obj;
			if (name.equals(p.name) && age==p.age)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		return false;
	}
}

Which are the following hascode method are approriate for person class.
1.public int hashCode(){return 100; }
2.public int hashCode(){return age + ssno; }
3.public int hashCode(){return name.hashCode() + age; }
4.No restrictions.

Ans:3

Note: 
Based on which parameter we override .equals method, it is highly recommended to use same 
parameter while overriding hashCode method also.

Note:
In all collection classes,in all wrapper classes and in String classes .equals method is 
overriden for content comparison hence it is highly recommended to override in our class for 
content comparison.


						Part-13:
						========
The process of creating exact duplicate object is callled Cloning.
The main purpose of cloning is to maintain backup copy and preserve state of an object.
We can perform cloning by using clone method of object class.
	protected native Object clone() throws CloneNotSupportedException

eg:
class Test implements Cloneable
{
	int i=10;
	int j=20;
	public static void main(String[] args) throws CloneNotSupportedException
	{
		Test t1=new Test();
		Test t2=(Test)t1.clone();
		t2.i=888;
		t2.j=999;
		System.out.println(t1.i + "...."+t1.j);
		System.out.println(t2.i + "...."+t2.j);
	}
}

We perform cloning only for cloneable objects.
An object is said to be cloneable if and only if corresponding class implements Cloneable interface.
Cloneable interface present in java.lang package and it doesnt contain any methods.
It is Marker interface.

If we are trying to perform cloning for non-cloneable object then we will get runtime exception
saying CloneNotSupportedException.

Shalow cloning vs Deep Cloning:
-------------------------------
Shallow cloning:
-The process of  creating bitwise copy of object is called Shallow Cloning.
-If the the main object contain primitive variables then exact duplicate copy will be created in
cloned object.
-If the main object contain any reference variables then corresponding object wont be created 
just duplicate reference variables will be created pointing to old content object.
-Object class clone method meant for shallow cloning.

eg:
class Cat
{
	int j;
	Cat(int j)
	{
		this.j=j;
	}
}
class Dog implements Cloneable
{
	Cat c;
	int i;
	Dog(Cat c,int i)
	{
		this.c=c;
		this.i=i;
	}
	public Object clone() throws CloneNotSupportedException
	{
		return super.clone();
	}
}
class ShallowCloning
{
	public static void main(String[] args) throws CloneNotSupportedException
	{
		Cat c=new Cat(20);
		Dog d1=new Dog(c,10);
		System.out.println(d1.i+"...."+d1.c); //10...20
		Dog d2=(Dog)d1.clone();
		d2.i=888;
		d2.c.j=999;
		System.out.println(d1.i+"...."+d1.c.j);//10...999
	}
}


In shalow cloning by using cloned object reference if we perform any change to content object 
then those changes will be reflected to the main object.

To overcome this problem we should go for deep cloning.


Deep Cloning:
The process of creating exact duplicate indepent copy including content object is called Deep
Cloning.

In Deep cloning if the main object contain any primitive variable then in cloned object duplicate
copy will be created.

If main object contain any reference varibale then the corresponding content object will be created 
in a cloned copy.

By Default object class clone method meant for shallow cloning but we can implement deep cloning 
explicitly by overriding clone method in our class.


eg:
class Cat
{
	int j;
	Cat(int j)
	{
		this.j=j;
	}
}
class Dog implements Cloneable
{
	Cat c;
	int i;
	Dog(Cat c,int i)
	{
		this.c=c;
		this.i=i;
	}
	public Object clone() throws CloneNotSupportedException
	{
		Cat c1=new Cat(c,j);
		Dog d=new Dog(c1,i);
		return d;
	}
}
class DeepCloning
{
	public static void main(String[] args) throws CloneNotSupportedException
	{
		Cat c=new Cat(20);
		Dog d1=new Dog(c,10);
		System.out.println(d1.i+"...."+d1.c); //10...20
		Dog d2=(Dog)d1.clone();
		d2.i=888;
		d2.c.j=999;
		System.out.println(d1.i+"...."+d1.c.j);//10...20
	}
}

By using cloned object reference if we perform any change to the contained object then those 
changes wont be reflected to the main object.

Which cloning is the best:
If object contains only primitive variables then shallow cloning is the best choice.
If object contains reference variables then Deep cloning is best choice.

