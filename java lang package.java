java.lang package
=================
1.Introduction
2.Object class 
3.String class 
4.StringBuffer class
5.StringBuilder class
6.Wrapper class
7.Autoboxing & Autounboxing 
=================================


1.Introduction
---------------
We are not required to import java.lang package explicitly because all classess and 
interfaces present in lang package by default available to every java program.

2.Object class(java.lang.Object) 
--------------------------------
The most required method for every java class (whether it is predefined or customezed class)
are defined in separate class which is Object class.

Every class in java is child class of Object either directly or indirectly so that 
Object class methods by default available to every java class.

Hence Object class is considered as Root of java class.

Note:
If our class does not extend any other class then only our class is directly class 
of Object.

Example:
	class A
	{
	}
class A is child of Object.

If our class extends other class then our class is indirectly child class of Object.
Example:
	class A extends B
	{
	}
class A is a child of class B and B is child of class Object. This is multi-level inheritance and 
not multiple inheritance.
Java does not support multiple inheritance but support multi-level inheritance.

conclusion:
Either directly or indirectly Java will not support multiple inheritance with respect 
to classes.

Object class defines the following 11 methods:
1.public String toString()
2.public int hashcode()
3.public boolean equals(Object o)
4.protected native Object clone() throws CloneNotSupportedException
5.protected void finalize() throws Throwable
6.public final class getclass()
7.public final void wait() throws InterruptedException
8.public final native void wait(long ms) throws InterruptedException
9.public final void wait(long ms,int ns) throws InterruptedException
10.public native final void notify()
11.public native final void notifyAll() 

Note:
Strictly Object class class contains 12 methods the extra method is
private static native void registerNatives()
This method internally required for object class and not available for child classes
hence we are not required to consider this method.

code to list methods in object class:

import java.lang.reflect.*;	
class Test
	{
		public static void main(String [] args ) throws Exception
		{
			int count=0;
			class c=class.forName("java.lang.Object")
			Method[] m=c.getDeclaredMethods();
			for (Method m1:m )
			{
				count ++;
				System.out.println(m1.getName());
			}
			System.out.println("There is a number methods:" + count);
		}
	}


tostring ()
-----------
We can use tostring () method to get String repsentation of an object.
String s=obj.toString();

Whenever we trying to print object reference internally toString() method will be 
called.
Example:
Student s=new Student();
System.out.println(s); ====(System.out.println(s.toString())

if our class does not contain toString() method then Object class toString() method will
be excuted.
class Student 
{
	String name;
	int rollno;
	Student(String name,int rollno)
	{
		this.name=name;
		this.rollno=rollno;
	}
	public static void main(String[] args)
	{
		Student s1=new Student("eurad",101);
		Student s2=new Student("emma",102);
		
		System.out.println(s1);
		System.out.println(s1.toString());
		System.out.println(s2);
	}
}


Based on our requirement we can override toString() method to provide our own 
String representation.
Example:
class Student 
{
	String name;
	int rollno;
	Student(String name,int rollno)
	{
		this.name=name;
		this.rollno=rollno;
	}
	public String toString()
	{
		return name +"..."+ rollno;
	}
	public static void main(String[] args)
	{
		Student s1=new Student("eurad",101);
		Student s2=new Student("emma",102);
		
		System.out.println(s1);
		System.out.println(s1.toString());
		System.out.println(s2);
	}
}

2.public native int hashcode()
------------------------
For every object a unique number generated by JVM which is nothing but Hashcode.
Hashcode will not represent address of object.
JVM will use hashcode while saving object to hashing related datastructures like 
Hashtable,HashSet,HashMap ...etc

The main advantage of saving objects based on hashcode is Search Operation will 
become easy(the most powerful seach algorithm up to today is Hashing)

if we are giving to object class hashcode method it will generate hashcode 
based on address of obaject. It does not mean hashcode repsent address of object.

Based on our requirement we can override hashcode method in class to generate 
our own hashcode.

Overriding hashcode method is said to proper if and only if for every object we have
to generate a unique number as hashcode.
Example:
class Test
{	
	public static void main(String[] args)
	{
		return 100;	//improper way 
	}
}
This is improper way of overriding hashcode method because for all student object 
we are generating same number as hashcode.

Example:
class Test
{	
	public static void main(String[] args)
	{
		return rollno;	//proper way 
	}
}
This is proper way of overriding hashcode method because we are generating a different 
hashcode for every object.

toString() vs hashcode():
-------------------------
if we are giving a chance to object class to string method it will internally call
hashcode method.
public String toString()
{
	return get.class().getName +"@"+ Integer.toHexString(hashcode());
}

if we are overriding toString method then our toString method may not call hashcode 
method.
public String toString()
{
	return name +"..."+ rollno;
}

Example:
class Test
{
	Test(int i)
	{
		this.i=i;
	}
	public static void main(String[] args)
	{
		Test t1=new Test(10);
		Test t1=new Test(100);
		System.out.println(t1);		//Test@abcd
		System.out.println(t2);		//Test@abdf
	}
}

Example:
class Test
{
	Test(int i)
	{
		this.i=i;
	}
	public int hashcode()
	{
		return i;
	}
	public static void main(String[] args)
	{
		Test t1=new Test(10);
		Test t1=new Test(100);
		System.out.println(t1);		//Test@a
		System.out.println(t2);		//Test@64
	}
}

In all Wrapper classes,in all collections classes,String class,StringBuffer 
and StringBuilder classes toString method is overriden for meaningful String
repsentation hence it is recommended to override toString() method in our 
class also.


3.String class 
4.StringBuffer class
5.StringBuilder class
6.Wrapper class
7.Autoboxing & Autounboxing